# № Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Катаев Ю.И.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Метод поиска в пространстве состояний является основным методом решения задач искусственного интеллекта, и именно пространство состояний определяет вид конечного решения. Множество решений при таком подходе представляется ориентированным графом, вершинами которого являются текущие состояния, а ребрами - переходы. Достижение решения сводится к поиску кратчайшего пути до него.

Очень часто в программировании графы задаются матрицей смежностей, что является не самым удобным представлением графа. Задание графа при помощи дуг является более гибким, чем матрица смежности, поскольку дуги могут задаваться не только явным перечислением, но и при помощи правил, что позволяет нам описывать очень сложные и большие графы, для которых матричное представление нерационально и вообще не всегда возможно.

Наконец, можно сказать, что язык Prolog фактически основан на графах, так как дерево решений представляет собой граф, обход которого осуществляется с помощью обхода в глубину.

## Задание

Вариант 8. Вдоль доски расположены лунки, в каждой из которых лежит красный, белый или синий шар. Одним ходом можно менять местами два любых шара. Добиться того, чтобы сначала шли все красные шары, все синие - последними, а белые - посередине. Решить задачу за наименьшее число ходов. 

## Принцип решения

Основной принцип решения задачи: идем по списку, перебирая по 2 шара, проверяем лежат ли эти шары в правильной последовательности, если нет, то меняем их местами. 

Я использовал 3 алгоритма поиска: поиск в глубину, поиск в ширину и поиск с итеративным погружением. Они отражены в предикатах search_dfs, search_bfs и search_id соответственно.

Предикат `prolong` нужен, чтобы продлить все пути в графе, предотвращая зацикливания. 
```prolog 
prolong([X|T], [Y, X|T]) :-
    move(X, Y),
    not(member(Y, [X|T])).
```

Предикат `move` описывает переход между состояниями в графе. Во втором правиле проходим по списку, представляющему одно состояние, меняем элементы, стоящие не на своем месте, что позволяет получить другое состояние.
```prolog
move([H|_], Res):-
    move(H, Res).

move(state(L), state(ResL)):-
    length(L, Len),
    Len1 is Len - 1,
    between(0, Len1, A),
    between(0, Len1, B),

    A < B,
    check_correct(L, A, B),
    swap(L, A, B, X),

    ResL = X.
```
Предикат `between` генерирует все целые числа от 0 до Len, т.е. генерируем все числа от 0 до длины списка.Далее идёт проверка, правильно ли стоят элементы с меньшим порядковым индексом относительно элементов с большим порядковым индексом, и если нужно, меняем эти элементы.

В предикате `check_correct` проверяется правильный порядок шаров. За синим шаром не могут лежать красный или белый, за белым шаром не может лежать красный.

```prolog
check_correct(L,N,M) :-
    getElem(L,X,N),
    getElem(L,Y,M),
    ((X == blue, Y == red);
    (X == blue, Y == white);
    (X == white, Y == red)), !.
```
## Результаты

Результат работы:
```prolog
?- search_dfs(state([red,blue,white,red,red,white,white,blue]),state([red,red,red,white,white,white,blue,blue])).
DFS START
state([red,blue,white,red,red,white,white,blue])
state([red,white,blue,red,red,white,white,blue])
state([red,red,blue,white,red,white,white,blue])
state([red,red,white,blue,red,white,white,blue])
state([red,red,red,blue,white,white,white,blue])
state([red,red,red,white,blue,white,white,blue])
state([red,red,red,white,white,blue,white,blue])
state([red,red,red,white,white,white,blue,blue])
DFS END

TIME IS 0.008799076080322266

true .

?- search_bfs(state([red,blue,white,red,red,white,white,blue]),state([red,red,red,white,white,white,blue,blue])).
BFS START
state([red,blue,white,red,red,white,white,blue])
state([red,red,white,blue,red,white,white,blue])
state([red,red,red,blue,white,white,white,blue])
state([red,red,red,white,white,white,blue,blue])
BFS END

TIME IS 0.011297941207885742

true .

?- search_id(state([red,blue,white,red,red,white,white,blue]),state([red,red,red,white,white,white,blue,blue])).
ITER START
state([red,blue,white,red,red,white,white,blue])
state([red,red,white,blue,red,white,white,blue])
state([red,red,red,blue,white,white,white,blue])
state([red,red,red,white,white,white,blue,blue])
ITER END

TIME IS 0.0028409957885742188

true .
```
## Выводы
В ходе лабораторной работы мною был изучен ещё один способ решения логических задач, а именно метод поиска в пространстве состояний. Для этого я дополнительно изучил различные алгоритмы поиска в графах и научился их реализовывать средствами языка Prolog.

Все три алгоритма справились со своей задачей, но наиболее эффективным оказался поиск с итеративным погружением. Он нашел решение быстрее других за наименьшее число шагов. Отличие его в том, что он ищет кратчайший путь, т.е. если путь нашелся, алгоритм закончил работу и дальше не будет перебирать варианты. Алгоритм итеративного погружения вбирает в себя лучшие черты поиска в глубину и в ширину.

Поиск в ширину имеет экспоненциальную сложность как по времени, так и по памяти (на определённых входных данных он может привести к переполнению стека и падению программы, что и произошло со мной на одном из тестов). Поиск в глубину, весьма экономичен по памяти, но в своей наивной реализации неустойчив, и расточителен по времени, как и поиск в ширину. Конечно, нам может повезти, и решение найдется сразу, но на практике это маловероятно.

В целом, необходимо выбирать алгоритм в зависимости от задачи, поскольку каждый алгоритм имеет свои преимущества и недостатки. Конечно, лучше всего использовать эвристический поиск, что чаще и делают на практике. В отличие от использованных мной алгоритмов, эвристический поиск ищет в пространстве состояний более целенаправленно, т.к. имеет функцию оценки состояния. А вот метод поиска в пространстве состояний оказался очень удобным, поскольку часто достаточно поменять условия перехода состояний для решения другой задачи.


