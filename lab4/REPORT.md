# № Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Катаев Ю.И.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Обработка искусственных и особенно естественных языков (NLP) является актуальной задачей в настоящее время. При обработке таких языков используются алгоритмы машинного обучения. 

Существуют 2 метода обработки естественного языка: статистический и лингвистический. В основе статистического подхода лежит предположение, что содержание текста отражается в наиболее часто встречающихся словах. Главный недостаток статистических методов состоит в невозможности учесть связность текста. Эту проблему решает лингвистический метод, который разбивает текст на уровни и помогает учитывать связи между словами и предложениями.

Так как построение предложений в языках осуществляется по определенным правилам, не так сложно описать эти правила при помощи языка Prolog, который будет искать соответствия предложений с некоторой описанной структурой.

## Задание

Реализовать синтаксический анализатор арифметического выражения для перевода его в префиксную форму. В выражении допустимы операции +,-,*,/. 

## Принцип решения

Удобно решать задачу подсчета арифметического выражения рекурсивно. Находим операцию с минимальным приоритетом (-, +, *, /). Через предикат append делим наш список на выражение до операции (A) и на выражение после операции (B). Далее этот же предикат запускаем для каждого из полученных выражений. В итоге пролог дойдет до самой первой операцией над числами. Тогда он вернет префиксную форму этого выражения. Для этого был написан вспомогательный предикат `prefix`. 

```prolog
prefix(X, Y, OP, Ans) :- 
    append(X, Y, R),
    append(OP, R, Ans).

calculate([N], [N]).
calculate(Seq, Ans) :- append(A, ['-'|B], Seq), calculate(A, X), calculate(B, Y), !, prefix(X, Y, ['-'], Ans).
calculate(Seq, Ans) :- append(A, ['+'|B], Seq), calculate(A, X), calculate(B, Y), !, prefix(X, Y, ['+'], Ans).
calculate(Seq, Ans) :- append(A, ['*'|B], Seq), calculate(A, X), calculate(B, Y), !, prefix(X, Y, ['*'], Ans).
calculate(Seq, Ans) :- append(A, ['/'|B], Seq), calculate(A, X), calculate(B, Y), !, prefix(X, Y, ['/'], Ans).
```

## Результаты
```prolog
?- calculate([5, '*', 7, '+', 8, '-', 4, '*', 2], X). 
X = [-, +, *, 5, 7, 8, *, 4, 2].

?- calculate([10, '/', 5, '-', 4, '*', 5, '+', 2], X).      
X = [-, /, 10, 5, +, *, 4, 5, 2].

?- calculate([5, '*', 5, '+', 1, '*', 4, '*', 3], X).         
X = [+, *, 5, 5, *, 1, *, 4, 3].

?- calculate([1, '+', 1, '+', 1, '+', 1, '+',1], X).  
X = [+, 1, +, 1, +, 1, +, 1, 1].
```
## Выводы

В Подводя итог, данная работа показала мне, что Prolog является отличным инструментом для обработки арифметического выражения. На традиционном языке потребовалось бы описывать понятие дерева, вводить новые типы данных, пришлось бы работать с указателями и т.д. В Prolog же мы легко рекурсивно разбираем выражение.

 Также благодаря этой работе я уверенно научился пользоваться рекурсией в Prolog. Prolog является прекрасно справляется с решением задач грамматического разбора из-за своей компактности, внутреннего устройства и парадигмы программирования.



